# -*- coding: utf-8 -*-
"""EraseBackground.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eDblap754pZ4a4A5WPE0DVmwmHb09dEZ
"""

# Tính độ dài vector - cách 1
import numpy as np
def compute_vector_lenghth(vector):
  norm = np.sqrt(np.sum([v**2 for v in vector]))
  return norm
# Tính độ dài vector - cách 2
def  compute_vetor_length2(vector):
  len_of_vector = np.linalg.norm(vector) # Sử dụng hàm có sẵn trong thư viện Numpy
  return len_of_vector

# Nhân hai vector - cách 1
def compute_dot_product(vector1,vector2):
  dot_product = np.dot(vector1,vector2)
  return dot_product
v1 = np.array([0,1,-1,2])
v2 = np.array([2,5,1,0])
print(round(compute_dot_product(v1,v2),2))
print(v1.dot(v2)) # Cách 2

x = np.array([[-1,2],
            [3,-4]])
k = np.array([1,2])
print(x@k) # Cách 3

# Nhân ma trận với vector
def matrix_multi_vector(matrix,vector):
  return matrix.dot(vector)
m = np.array([[-1,1,1], [0,-4,9]])
v = np.array([0,2,1])
print(matrix_multi_vector(m,v))

# Nhân ma trận với ma trận
def matrix_multi_matrix(matrix1,matrix2):
  return matrix1.dot(matrix2)
m1 = np.array([[1,2,3],[4,5,6]])
m2 = np.array([[1,2],[3,4],[5,6]])
print(m1.shape)
print(m2.shape)
print(matrix_multi_matrix(m1,m2))

# Đảo ngược ma trận
def inverse_matrix(matrix):
  return np.linalg.inv(matrix)
A = np.array([[-2,6],[8,-4]])
B = np.array([[-4,-6],[-8,-2]])
detA = -40
InverseA = 1/detA * B
print(inverse_matrix(A))
print(InverseA)

# Tìm Eigenvalues, Eigenvectors
def compute_eigenvalues_eigenvectors(matrix):
  eigenvalues,eigenvectors = np.linalg.eig(matrix)
  return eigenvalues,eigenvectors
C = np.array([[0.9,0.2],[0.1,0.8]])
print(compute_eigenvalues_eigenvectors(C))

# Tính Cosine Similarity
from numpy import dot
from numpy.linalg import norm
def cosine_similarity(vector1,vector2):
  return np.dot(vector1,vector2)/(np.linalg.norm(vector1)*np.linalg.norm(vector2))
x = [1,2,3,4]
y = [1,0,3,0]
print(cosine_similarity(x,y))

# Xóa nền và chèn object vào nền mới
import numpy as np
from google.colab.patches import cv2_imshow
import cv2
bg1_image = cv2.imread('GreenBackground.png',1) # background1 có size là (678,381)
ob_image = cv2.imread('Object.png',1)
bg2_image = cv2.imread('NewBackground.jpg',1)
# Đồng bộ size cho tất cả các hình
IMAGE_SIZE = (678,381)
bg1_image = cv2.resize(bg1_image,IMAGE_SIZE)
ob_image = cv2.resize(ob_image,IMAGE_SIZE)
bg2_image = cv2.resize(bg2_image,IMAGE_SIZE)

# Tính differnce
def compute_difference(bg_img,input_img):
  difference_three_channel = cv2.absdiff(bg_img,input_img) # Tách object
  difference_single_channel = np.sum(difference_three_channel, axis =2 ) / 3.0 # Chuyển thành ảnh đơn kênh (trắng đen)
  difference_single_channel = difference_single_channel.astype('uint8') # Chuyển đổi kiểu dữ liệu sang unsinged 8 bit
  return difference_single_channel

difference_single_channel = compute_difference(bg1_image,ob_image)
cv2_imshow(difference_single_channel)

# Convert to binary image - Chuyển thành ảnh nhị phân đơn kênh
def compute_binary_image(difference_single_channel):
  difference_binary = np.where(difference_single_channel >=15, 255, 0) # Chuyển đổi các điểm dữ liệu > 15 thành màu trắng (255), hoặc màu đen (0)
  difference_binary = np.stack((difference_binary,)*3,axis= -1) # Sử dụng axis=-1 sẽ tạo ra một mảng ba kênh (RGB) từ ảnh nhị phân đơn kênh, với ba kênh giống nhau cho các giá trị màu đỏ, xanh lục và xanh dươn
  return difference_binary

binary_mask = compute_binary_image(difference_single_channel)
cv2_imshow(binary_mask)

# Thay vào background mới
def replace_backround(bg1_image, bg2_image, ob_image):
  difference_single_channel = compute_difference(bg1_image,ob_image)
  binary_mask = compute_binary_image(difference_single_channel)
  output = np.where(binary_mask == 255, ob_image, bg2_image) # Tại điểm ảnh màu trắng, thay bằng ảnh object, tại điểm ảnh màu đen thay bằng background mới
  return output

output = replace_backround(bg1_image, bg2_image, ob_image)
cv2_imshow(output)

# Câu 1
vector = np.array([-2,4,9,21])
result3 = compute_vetor_length2([vector])
print(round(result3),2)

# Câu 2
v1 = np.array([0,1,-1,2])
v2 = np.array([2,5,1,0])
result4 = compute_dot_product(v1,v2)
print(result4)

# Câu 3
x = np.array([[1,2],
            [3,4]])
k = np.array([1,2])
result5 = x@k
print(result5)

# Câu 4
x = np.array([[-1,2],
            [3,-4]])
k = np.array([1,2])
result6 = x@k
print(result6)

# Câu 5
m = np.array([[-1,1,1], [0,-4,9]])
v = np.array([0,2,1])
result7 = matrix_multi_vector(m,v)
print(result7)

# câu 6
m1 = np.array([[0,1,2],[2,-3,1]])
m2 = np.array([[1,-3],[6,1],[0,-1]])
result8 = matrix_multi_matrix(m1,m2)
print(result8)

# Câu 7
m1 = np.eye(3)
m2 = np.array([[1,1,1],[2,2,2],[3,3,3]])
result9 = m1@m2
print(result9)

# Câu 8
m1 = np.eye (2)
m1 = np. reshape (m1 ,( -1 ,4) ) [0]
m2 = np. array ([[1 , 1 , 1 , 1] ,[2 , 2 , 2 , 2] , [3 , 3 , 3 , 3] , [4 , 4 , 4 , 4]])
result = m1@m2
print ( result )

# Câu 9
m1 = np. array ([[1 , 2] , [3 , 4]])
m1 = np. reshape (m1 ,( -1 ,4) , "F") [0]
m2 = np. array ([[1 , 1 , 1 , 1] ,[2 , 2 , 2 , 2] , [3 , 3 , 3 , 3] , [4 , 4 , 4 , 4]])
result = m1@m2
print ( result )

# câu 10
m1 = np. array ([[ -2 , 6] , [8 , -4]])
result = inverse_matrix (m1)
print ( result )

# Câu 11
matrix = np. array ([[0.9 , 0.2] , [0.1 , 0.8]])
eigenvalues , eigenvectors = compute_eigenvalues_eigenvectors ( matrix )
print ( eigenvectors )

# câu 12
x = np. array ([1 , 2 , 3 , 4])
y = np. array ([1 , 0 , 3 , 0])
result = cosine_similarity (x,y)
print ( round (result , 3) )

