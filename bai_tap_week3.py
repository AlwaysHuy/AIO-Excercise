# -*- coding: utf-8 -*-
"""Bài tập week3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YedVU6a7zARm_UqSvdM5LOsZTrARkU0x
"""

# Bài tập 1
import torch
import torch.nn as nn

data = torch.Tensor([1 , 2 , 3])
data

softmax_function = nn.Softmax(dim=0)
output = softmax_function(data)
output

class MySoftmax(nn.Module):
    def __init__(self):
        super().__init__()
    def forward(self, input):
      input_exp = torch.exp(input)
      total = input_exp.sum(0,keepdim=True)
      return input_exp/total

data3 = torch.Tensor([5,2,4])
my_softmax = MySoftmax()
output3 = my_softmax(data3)
assert round(output3[-1].item() , 2) == 0.26
output3

data4 = torch.Tensor([1,2,300000000])
output4 = my_softmax(data4)
assert round(output4[0].item(),2) == 0.0
output4

class MyStableSofmax(nn.Module):
  def __init__(self):
    super().__init__()
  def forward(self,input):
    c= torch.max(input, dim = 0, keepdims=True)
    input_exp = torch.exp(input-c.values)
    total = input_exp.sum(0,keepdims=True)
    return input_exp/total

# Câu hỏi trắc nghiệm 4
my_stable_softmax = MyStableSofmax()
output2 = my_stable_softmax(data)
output2

# Bài tập 2
from abc import ABC, abstractmethod
class Person:
  def __init__(self, name : str , yob : int):
    self.name = name
    self.yob = yob
  def get_yob(self):
    return self.yob
  @abstractmethod
  def describes(self):
    pass

class Student(Person):
  def __init__(self, name : str , yob : int , grade : str):
    super().__init__(name, yob)
    self.grade = grade
  def describes(self):
    return print(f'Studen - Name : {self.name} - YoB : {self.yob} - Grade : {self.grade}')

class Teacher(Person):
  def __init__(self, name : str, yob : int , subject : str):
    super().__init__(name, yob)
    self.subject = subject
  def describes(self):
    return print(f'Teacher - Name : {self.name} - YoB : {self.yob} - Subject : {self.subject}')

class Doctor(Person):
  def __init__(self, name : str  , yob : int , specialist : str):
    super().__init__(name , yob)
    self.speacialist = specialist
  def describes(self):
    return print(f'Doctor - Name : {self.name} - YoB : {self.yob} - Speacialist : {self.speacialist}')
class Ward:
  def __init__(self, name : str):
    self.name = name
    self.member_list = list()
  def add_person(self,person : Person):
    self.member_list.append(person)
  def describes(self):
    for p in self.member_list:
      p.describes()
  def  count_doctor(self):
    count = 0
    for p in self.member_list:
      if isinstance(p, Doctor):
        count += 1
    return count
  def  sort_by_yob(self):
    self.member_list.sort(key=lambda x: x.get_yob(), reverse=True)
    return self.member_list
  def teacher_yob_average(self):
    sum = 0
    count = 0
    for p in self.member_list:
      if isinstance(p, Teacher):
        sum += p.get_yob()
        count += 1
    return sum/count

student1 = Student(name="studentA", yob=2010, grade="7")
student1.describes()

teacher1 = Teacher(name="teacherA", yob=1969, subject="Math")
teacher1.describes()

doctor1 = Doctor(name="doctorA", yob=1945, specialist="Endocrinologists")
doctor1.describes()

studentz = Student ( name =" studentZ2023 ", yob =2011 , grade ="6")
assert studentz . yob == 2011
studentz.describes()

teacherz = Teacher ( name =" teacherZ2023 ", yob =1991 , subject =" History ")
assert teacherz . yob == 1991
teacherz.describes()

doctorz = Doctor ( name =" doctorZ2023 ", yob =1981 , specialist =" Endocrinologists ")
assert doctorz.yob == 1981
doctorz.describes()

student1 = Student ( name =" studentA ", yob =2010 , grade ="7")
teacher1 = Teacher ( name =" teacherA ", yob =1969 , subject =" Math ")
teacher2 = Teacher ( name =" teacherB ", yob =1995 , subject =" History ")
doctor1 = Doctor ( name =" doctorA ", yob =1945 , specialist =" Endocrinologists ")
doctor2 = Doctor ( name =" doctorB ", yob =1975 , specialist =" Cardiologists ")
ward1 = Ward ( name =" Ward1 ")
ward1 . add_person ( student1 )
ward1 . add_person ( teacher1 )
ward1 . add_person ( teacher2 )
ward1 . add_person ( doctor1 )
ward1 . add_person ( doctor2 )
ward1 . count_doctor ()

class MyStack:
  def __init__(self, capacity):
    self.__capacity = capacity
    self.__stack = []
  def is_full(self):
    return len(self.__stack) == self.__capacity
  def push (self, value):
    if not self.is_full():
      self.__stack.append(value)
  def is_empty(self):
    return len(self.__stack) == 0
  def top(self):
    return self.__stack[-1]
  def pop(self):
    if not self.is_empty():
      return self.__stack.pop()

stack1 = MyStack(5)
stack1.push(1)
assert stack1.is_full() == False
stack1.push(2)
print(stack1.is_full())
print(stack1.top())

class MyQueue:
  def __init__(self, capacity):
    self.__capacity = capacity
    self.__queue = []
  def is_full(self):
    return len(self.__queue) == self.__capacity
  def enqueue(self, value):
    if not self.is_full():
      self.__queue.append(value)
  def is_empty(self):
    return len(self.__queue) == 0
  def front(self):
    return self.__queue[0]
  def dequeue(self):
    if not self.is_empty():
      return self.__queue.pop(0)

queue1 = MyQueue(5)
queue1.enqueue(1)
assert queue1.is_full() == False
queue1.enqueue(2)
print(queue1.is_full())
print(queue1.front())

